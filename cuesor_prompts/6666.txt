Ÿäÿß Cursorÿå ŸÜŸÅŸëÿ∞ ÿßŸÑÿ¢ŸÜ:
Step 1: Repository Interface (already exists - verify)
bashcd /mnt/storage/Konozy_ai

# Verify domain repository interface exists
cat core/domain/repositories/order_repository.py

Step 2: SQLAlchemy Repository Implementation
ŸÖŸÑŸÅ: core/infrastructure/database/repositories/__init__.py
python"""Database repositories."""
from .sqlalchemy_order_repository import SQLAlchemyOrderRepository

__all__ = ["SQLAlchemyOrderRepository"]

ŸÖŸÑŸÅ: core/infrastructure/database/repositories/sqlalchemy_order_repository.py
python"""
SQLAlchemy Order Repository Implementation.

Implements OrderRepository interface using SQLAlchemy and PostgreSQL.
"""
from typing import Optional, List
from datetime import datetime
from decimal import Decimal
import logging
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from core.domain.entities import Order
from core.domain.value_objects import OrderNumber, ExecutionID, Money, FinancialBreakdown, FinancialLine
from core.domain.repositories import OrderRepository
from core.infrastructure.database.models import OrderModel, OrderItemModel, FinancialLineModel


logger = logging.getLogger(__name__)


class SQLAlchemyOrderRepository(OrderRepository):
    """
    SQLAlchemy implementation of OrderRepository.
    
    Handles persistence of Order entities using PostgreSQL.
    """
    
    def __init__(self, session: AsyncSession):
        """
        Initialize repository with database session.
        
        Args:
            session: SQLAlchemy async session
        """
        self.session = session
    
    async def save(self, order: Order) -> None:
        """
        Save or update order in database.
        
        Args:
            order: Order entity to persist
        """
        logger.info(f"Saving order: {order.order_id.value}")
        
        # Check if order already exists
        result = await self.session.execute(
            select(OrderModel).where(OrderModel.order_id == order.order_id.value)
        )
        existing_order = result.scalar_one_or_none()
        
        if existing_order:
            # Update existing order
            await self._update_order(existing_order, order)
            logger.info(f"‚úÖ Updated order: {order.order_id.value}")
        else:
            # Create new order
            await self._create_order(order)
            logger.info(f"‚úÖ Created order: {order.order_id.value}")
        
        # Commit changes
        await self.session.commit()
    
    async def get_by_id(self, order_id: OrderNumber) -> Optional[Order]:
        """
        Get order by ID.
        
        Args:
            order_id: Order ID to lookup
        
        Returns:
            Order entity if found, None otherwise
        """
        logger.info(f"Getting order: {order_id.value}")
        
        # Query with eager loading of relationships
        result = await self.session.execute(
            select(OrderModel)
            .options(
                selectinload(OrderModel.items),
                selectinload(OrderModel.financial_lines)
            )
            .where(
                and_(
                    OrderModel.order_id == order_id.value,
                    OrderModel.is_deleted == False
                )
            )
        )
        
        order_model = result.scalar_one_or_none()
        
        if not order_model:
            logger.info(f"Order not found: {order_id.value}")
            return None
        
        # Convert to domain entity
        order = self._to_domain_entity(order_model)
        
        logger.info(f"‚úÖ Found order: {order_id.value}")
        return order
    
    async def delete(self, order_id: OrderNumber) -> None:
        """
        Soft delete order.
        
        Args:
            order_id: Order ID to delete
        """
        logger.info(f"Deleting order: {order_id.value}")
        
        result = await self.session.execute(
            select(OrderModel).where(OrderModel.order_id == order_id.value)
        )
        
        order_model = result.scalar_one_or_none()
        
        if order_model:
            # Soft delete
            order_model.is_deleted = True
            order_model.deleted_at = datetime.utcnow()
            
            await self.session.commit()
            logger.info(f"‚úÖ Deleted order: {order_id.value}")
        else:
            logger.warning(f"Order not found for deletion: {order_id.value}")
    
    async def find_by_marketplace(
        self,
        marketplace: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[Order]:
        """
        Find orders by marketplace.
        
        Args:
            marketplace: Marketplace name (e.g., 'amazon', 'noon')
            limit: Maximum number of results
            offset: Number of results to skip
        
        Returns:
            List of orders
        """
        logger.info(f"Finding orders for marketplace: {marketplace}")
        
        result = await self.session.execute(
            select(OrderModel)
            .options(
                selectinload(OrderModel.items),
                selectinload(OrderModel.financial_lines)
            )
            .where(
                and_(
                    OrderModel.marketplace == marketplace,
                    OrderModel.is_deleted == False
                )
            )
            .order_by(OrderModel.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        
        order_models = result.scalars().all()
        
        orders = [self._to_domain_entity(om) for om in order_models]
        
        logger.info(f"‚úÖ Found {len(orders)} orders for {marketplace}")
        return orders
    
    async def find_by_status(
        self,
        status: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[Order]:
        """
        Find orders by status.
        
        Args:
            status: Order status (e.g., 'Pending', 'Synced')
            limit: Maximum number of results
            offset: Number of results to skip
        
        Returns:
            List of orders
        """
        logger.info(f"Finding orders with status: {status}")
        
        result = await self.session.execute(
            select(OrderModel)
            .options(
                selectinload(OrderModel.items),
                selectinload(OrderModel.financial_lines)
            )
            .where(
                and_(
                    OrderModel.order_status == status,
                    OrderModel.is_deleted == False
                )
            )
            .order_by(OrderModel.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        
        order_models = result.scalars().all()
        
        orders = [self._to_domain_entity(om) for om in order_models]
        
        logger.info(f"‚úÖ Found {len(orders)} orders with status {status}")
        return orders
    
    def get_all(self) -> List[Order]:
        """
        Get all orders (synchronous - for compatibility).
        
        Note: This is sync wrapper for async method.
        Use find_all_async() for proper async usage.
        
        Returns:
            List of all orders
        """
        # This is a sync wrapper - not ideal but needed for compatibility
        # In production, use find_all_async() instead
        import asyncio
        return asyncio.run(self.find_all_async())
    
    async def find_all_async(
        self,
        limit: int = 1000,
        offset: int = 0
    ) -> List[Order]:
        """
        Find all orders (async).
        
        Args:
            limit: Maximum number of results
            offset: Number of results to skip
        
        Returns:
            List of all orders
        """
        logger.info("Finding all orders")
        
        result = await self.session.execute(
            select(OrderModel)
            .options(
                selectinload(OrderModel.items),
                selectinload(OrderModel.financial_lines)
            )
            .where(OrderModel.is_deleted == False)
            .order_by(OrderModel.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        
        order_models = result.scalars().all()
        
        orders = [self._to_domain_entity(om) for om in order_models]
        
        logger.info(f"‚úÖ Found {len(orders)} orders")
        return orders
    
    # =========================================================================
    # PRIVATE METHODS
    # =========================================================================
    
    async def _create_order(self, order: Order) -> None:
        """Create new order in database."""
        # Create order model
        order_model = OrderModel(
            order_id=order.order_id.value,
            execution_id=order.execution_id.value if order.execution_id else None,
            marketplace=order.marketplace,
            purchase_date=order.purchase_date,
            buyer_email=order.buyer_email,
            order_status=order.order_status,
            error_message=order.error_message,
        )
        
        # Add financial data if available
        if order.financial_breakdown:
            breakdown = order.financial_breakdown
            
            order_model.principal_amount = breakdown.principal.amount
            order_model.principal_currency = breakdown.principal.currency
            order_model.net_proceeds_amount = breakdown.net_proceeds.amount
            order_model.net_proceeds_currency = breakdown.net_proceeds.currency
            
            # Store full breakdown as JSON
            order_model.financial_breakdown = self._serialize_financial_breakdown(breakdown)
            
            # Create financial line models
            for line in breakdown.financial_lines:
                line_model = FinancialLineModel(
                    line_type=line.line_type,
                    description=line.description,
                    amount=line.amount.amount,
                    currency=line.amount.currency,
                    sku=line.sku
                )
                order_model.financial_lines.append(line_model)
        
        # Add order to session
        self.session.add(order_model)
    
    async def _update_order(self, order_model: OrderModel, order: Order) -> None:
        """Update existing order in database."""
        # Update basic fields
        order_model.marketplace = order.marketplace
        order_model.purchase_date = order.purchase_date
        order_model.buyer_email = order.buyer_email
        order_model.order_status = order.order_status
        order_model.error_message = order.error_message
        order_model.updated_at = datetime.utcnow()
        
        # Update execution ID if available
        if order.execution_id:
            order_model.execution_id = order.execution_id.value
        
        # Update financial data if available
        if order.financial_breakdown:
            breakdown = order.financial_breakdown
            
            order_model.principal_amount = breakdown.principal.amount
            order_model.principal_currency = breakdown.principal.currency
            order_model.net_proceeds_amount = breakdown.net_proceeds.amount
            order_model.net_proceeds_currency = breakdown.net_proceeds.currency
            order_model.financial_breakdown = self._serialize_financial_breakdown(breakdown)
            
            # Delete old financial lines
            for line_model in order_model.financial_lines:
                await self.session.delete(line_model)
            
            # Create new financial lines
            order_model.financial_lines = []
            for line in breakdown.financial_lines:
                line_model = FinancialLineModel(
                    line_type=line.line_type,
                    description=line.description,
                    amount=line.amount.amount,
                    currency=line.amount.currency,
                    sku=line.sku
                )
                order_model.financial_lines.append(line_model)
    
    def _to_domain_entity(self, order_model: OrderModel) -> Order:
        """Convert database model to domain entity."""
        # Reconstruct financial breakdown
        financial_breakdown = None
        
        if order_model.principal_amount is not None:
            # Reconstruct financial lines
            financial_lines = [
                FinancialLine(
                    line_type=line_model.line_type,
                    description=line_model.description,
                    amount=Money(
                        amount=line_model.amount,
                        currency=line_model.currency
                    ),
                    sku=line_model.sku
                )
                for line_model in order_model.financial_lines
            ]
            
            # Create financial breakdown
            financial_breakdown = FinancialBreakdown(
                principal=Money(
                    amount=order_model.principal_amount,
                    currency=order_model.principal_currency
                ),
                financial_lines=financial_lines,
                net_proceeds=Money(
                    amount=order_model.net_proceeds_amount,
                    currency=order_model.net_proceeds_currency
                )
            )
        
        # Reconstruct execution ID
        execution_id = None
        if order_model.execution_id:
            execution_id = ExecutionID(value=order_model.execution_id)
        
        # Create order entity
        order = Order(
            order_id=OrderNumber(value=order_model.order_id),
            purchase_date=order_model.purchase_date,
            buyer_email=order_model.buyer_email,
            financial_breakdown=financial_breakdown,
            execution_id=execution_id,
            marketplace=order_model.marketplace,
            order_status=order_model.order_status,
        )
        
        # Set error message if present
        if order_model.error_message:
            order.error_message = order_model.error_message
        
        return order
    
    def _serialize_financial_breakdown(self, breakdown: FinancialBreakdown) -> dict:
        """Serialize financial breakdown to JSON."""
        return {
            "principal": {
                "amount": str(breakdown.principal.amount),
                "currency": breakdown.principal.currency
            },
            "net_proceeds": {
                "amount": str(breakdown.net_proceeds.amount),
                "currency": breakdown.net_proceeds.currency
            },
            "financial_lines": [
                {
                    "line_type": line.line_type,
                    "description": line.description,
                    "amount": str(line.amount.amount),
                    "currency": line.amount.currency,
                    "sku": line.sku
                }
                for line in breakdown.financial_lines
            ]
        }

üî® Task 8.4: Unit of Work Pattern
ŸÖŸÑŸÅ: core/infrastructure/database/unit_of_work.py
python"""
Unit of Work Pattern Implementation.

Manages database transactions and repository lifecycle.
"""
from typing import Optional
import logging
from sqlalchemy.ext.asyncio import AsyncSession

from core.infrastructure.database.repositories import SQLAlchemyOrderRepository


logger = logging.getLogger(__name__)


class UnitOfWork:
    """
    Unit of Work pattern implementation.
    
    Manages database session lifecycle and transactions.
    Provides access to repositories within a transaction context.
    
    Usage:
        async with UnitOfWork(session) as uow:
            order = await uow.orders.get_by_id(order_id)
            order.mark_synced()
            await uow.orders.save(order)
            await uow.commit()
    """
    
    def __init__(self, session: AsyncSession):
        """
        Initialize Unit of Work.
        
        Args:
            session: SQLAlchemy async session
        """
        self.session = session
        self._orders: Optional[SQLAlchemyOrderRepository] = None
    
    async def __aenter__(self):
        """Enter async context."""
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """
        Exit async context.
        
        Rolls back transaction if exception occurred.
        """
        if exc_type is not None:
            logger.error(f"Transaction failed: {exc_val}")
            await self.rollback()
        
        await self.session.close()
    
    @property
    def orders(self) -> SQLAlchemyOrderRepository:
        """
        Get order repository.
        
        Returns:
            Order repository instance
        """
        if self._orders is None:
            self._orders = SQLAlchemyOrderRepository(self.session)
        
        return self._orders
    
    async def commit(self):
        """Commit transaction."""
        try:
            await self.session.commit()
            logger.info("‚úÖ Transaction committed")
        except Exception as e:
            logger.error(f"‚ùå Commit failed: {e}")
            await self.rollback()
            raise
    
    async def rollback(self):
        """Rollback transaction."""
        await self.session.rollback()
        logger.warning("Transaction rolled back")

‚úÖ ÿßŸÑÿ¢ŸÜ: Verification Script
ŸÖŸÑŸÅ: scripts/verify_database.py
python"""
Verify database setup.

Tests database connection, models, and basic operations.
"""
import asyncio
import logging
from datetime import datetime
from decimal import Decimal

from core.infrastructure.database.config import init_database, get_session, close_database
from core.infrastructure.database.unit_of_work import UnitOfWork
from core.domain.entities import Order
from core.domain.value_objects import (
    OrderNumber, ExecutionID, Money,
    FinancialBreakdown, FinancialLine
)


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def test_database():
    """Test database operations."""
    
    logger.info("="*80)
    logger.info("DATABASE VERIFICATION TEST")
    logger.info("="*80)
    
    try:
        # Initialize database
        logger.info("\n1. Initializing database...")
        await init_database()
        
        # Create test order
        logger.info("\n2. Creating test order...")
        
        breakdown = FinancialBreakdown(
            principal=Money(amount=Decimal("100.00"), currency="EGP"),
            financial_lines=[
                FinancialLine(
                    line_type="FBAFee",
                    description="FBA Fee",
                    amount=Money(amount=Decimal("-10.00"), currency="EGP"),
                    sku="TEST-SKU"
                )
            ],
            net_proceeds=Money(amount=Decimal("90.00"), currency="EGP")
        )
        
        order = Order(
            order_id=OrderNumber(value="TEST-001-001-001"),
            purchase_date=datetime.utcnow(),
            buyer_email="test@example.com",
            financial_breakdown=breakdown,
            execution_id=ExecutionID.generate(),
            marketplace="amazon",
            order_status="Pending"
        )
        
        logger.info(f"‚úÖ Test order created: {order.order_id.value}")
        
        # Save order
        logger.info("\n3. Saving order to database...")
        
        async for session in get_session():
            async with UnitOfWork(session) as uow:
                await uow.orders.save(order)
                await uow.commit()
        
        logger.info("‚úÖ Order saved successfully")
        
        # Retrieve order
        logger.info("\n4. Retrieving order from database...")
        
        async for session in get_session():
            async with UnitOfWork(session) as uow:
                retrieved_order = await uow.orders.get_by_id(
                    OrderNumber(value="TEST-001-001-001")
                )
        
        if retrieved_order:
            logger.info("‚úÖ Order retrieved successfully")
            logger.info(f"   Order ID: {retrieved_order.order_id.value}")
            logger.info(f"   Status: {retrieved_order.order_status}")
            logger.info(f"   Principal: {retrieved_order.financial_breakdown.principal.amount} EGP")
            logger.info(f"   Net: {retrieved_order.financial_breakdown.net_proceeds.amount} EGP")
        else:
            logger.error("‚ùå Order not found!")
        
        # Update order
        logger.info("\n5. Updating order...")
        
        async for session in get_session():
            async with UnitOfWork(session) as uow:
                order_to_update = await uow.orders.get_by_id(
                    OrderNumber(value="TEST-001-001-001")
                )
                
                if order_to_update:
                    order_to_update.mark_synced()
                    await uow.orders.save(order_to_update)
                    await uow.commit()
        
        logger.info("‚úÖ Order updated successfully")
        
        # Verify update
        logger.info("\n6. Verifying update...")
        
        async for session in get_session():
            async with UnitOfWork(session) as uow:
                updated_order = await uow.orders.get_by_id(
                    OrderNumber(value="TEST-001-001-001")
                )
        
        if updated_order and updated_order.order_status == "Synced":
            logger.info("‚úÖ Update verified - status is 'Synced'")
        else:
            logger.error("‚ùå Update verification failed!")
        
        # List all orders
        logger.info("\n7. Listing all orders...")
        
        async for session in get_session():
            async with UnitOfWork(session) as uow:
                all_orders = await uow.orders.find_all_async(limit=10)
        
        logger.info(f"‚úÖ Found {len(all_orders)} order(s)")
        
        logger.info("\n" + "="*80)
        logger.info("‚úÖ ALL TESTS PASSED!")
        logger.info("="*80)
        
    except Exception as e:
        logger.error(f"\n‚ùå TEST FAILED: {e}", exc_info=True)
    
    finally:
        # Cleanup
        await close_database()


if __name__ == "__main__":
    asyncio.run(test_database())

‚úÖ ÿßŸÑÿ¢ŸÜ: ÿßÿÆÿ™ÿ®ÿ±!
bashcd /mnt/storage/Konozy_ai

# Run verification script
python scripts/verify_database.py

ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿ™ŸÜŸÅŸäÿ∞ÿü üöÄ
ÿ£ÿÆÿ®ÿ±ŸÜŸä ÿ®ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ Ÿàÿ≥ÿ£ŸÉŸÖŸÑ ŸÖÿπ:

Task 8.5: Alembic Migrations
Task 8.6: Integration with API
