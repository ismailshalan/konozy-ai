Ÿäÿß Cursorÿå ŸÜŸÅŸëÿ∞ ÿßŸÑÿ¢ŸÜ:
Step 1: Create API structure
bashcd /home/claude

# Create API directory structure
mkdir -p api/routes
mkdir -p api/middleware

# Create __init__.py files
touch api/__init__.py
touch api/routes/__init__.py
touch api/middleware/__init__.py

Step 2: Main FastAPI App
ŸÖŸÑŸÅ: api/main.py
python"""
Konozy AI - Main FastAPI Application.

This is the REST API layer that provides HTTP endpoints
for Amazon order synchronization using Clean Architecture.
"""
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
import time

from api.routes import amazon, orders, health


# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# =============================================================================
# CREATE FASTAPI APP
# =============================================================================

app = FastAPI(
    title="Konozy AI - Order Management API",
    description="""
    Amazon Order Sync API with Clean Architecture.
    
    Features:
    - Amazon order synchronization to Odoo
    - Multi-SKU support
    - Financial validation
    - Batch processing
    - Order management
    
    Built with:
    - Domain-Driven Design
    - Clean Architecture
    - Hexagonal Architecture
    - CQRS patterns
    """,
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
)


# =============================================================================
# CORS MIDDLEWARE
# =============================================================================

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure based on your needs
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# =============================================================================
# REQUEST LOGGING MIDDLEWARE
# =============================================================================

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Log all requests with timing."""
    start_time = time.time()
    
    # Log request
    logger.info(f"‚Üí {request.method} {request.url.path}")
    
    # Process request
    response = await call_next(request)
    
    # Calculate duration
    duration = time.time() - start_time
    
    # Log response
    logger.info(
        f"‚Üê {request.method} {request.url.path} "
        f"[{response.status_code}] ({duration:.3f}s)"
    )
    
    return response


# =============================================================================
# GLOBAL EXCEPTION HANDLER
# =============================================================================

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Handle all uncaught exceptions."""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "detail": str(exc),
            "path": request.url.path
        }
    )


# =============================================================================
# STARTUP/SHUTDOWN EVENTS
# =============================================================================

@app.on_event("startup")
async def startup_event():
    """Run on application startup."""
    logger.info("üöÄ Konozy AI API starting up...")
    logger.info("üìö Swagger UI available at: /docs")
    logger.info("üìñ ReDoc available at: /redoc")


@app.on_event("shutdown")
async def shutdown_event():
    """Run on application shutdown."""
    logger.info("üëã Konozy AI API shutting down...")


# =============================================================================
# INCLUDE ROUTERS
# =============================================================================

app.include_router(
    health.router,
    tags=["Health"]
)

app.include_router(
    amazon.router,
    prefix="/api/v1/amazon",
    tags=["Amazon"]
)

app.include_router(
    orders.router,
    prefix="/api/v1/orders",
    tags=["Orders"]
)


# =============================================================================
# ROOT ENDPOINT
# =============================================================================

@app.get("/", tags=["Root"])
async def root():
    """API root endpoint."""
    return {
        "message": "Konozy AI - Order Management API",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health"
    }

Step 3: Health Check Route
ŸÖŸÑŸÅ: api/routes/health.py
python"""
Health check endpoints.

Used for monitoring and load balancer health checks.
"""
from fastapi import APIRouter
from datetime import datetime
import platform


router = APIRouter()


@router.get("/health")
async def health_check():
    """
    Health check endpoint.
    
    Returns system health status.
    """
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "konozy-ai",
        "version": "1.0.0",
        "python_version": platform.python_version(),
    }


@router.get("/health/ready")
async def readiness_check():
    """
    Readiness check endpoint.
    
    Returns whether the service is ready to accept traffic.
    """
    # TODO: Add checks for:
    # - Database connection
    # - Odoo connection
    # - Required services
    
    return {
        "status": "ready",
        "timestamp": datetime.utcnow().isoformat(),
        "checks": {
            "api": "ok",
            "database": "ok",  # TODO: Real check
            "odoo": "ok",      # TODO: Real check
        }
    }

üî® Task 9.2: Dependencies
ŸÖŸÑŸÅ: api/dependencies.py
python"""
FastAPI Dependencies.

Provides dependency injection for use cases and services.
"""
from functools import lru_cache
import logging

from core.application.use_cases.sync_amazon_order import SyncAmazonOrderUseCase
from core.application.services.amazon_sync_service import AmazonSyncService

# Mock implementations (replace with real ones later)
from core.infrastructure.adapters.persistence.mock_order_repository import MockOrderRepository
from core.infrastructure.adapters.odoo.mock_odoo_client import MockOdooClient
from core.infrastructure.adapters.notifications.mock_notification_service import MockNotificationService


logger = logging.getLogger(__name__)


# =============================================================================
# SINGLETON INSTANCES (for demo/testing)
# =============================================================================

_order_repository = None
_odoo_client = None
_notification_service = None
_sync_order_use_case = None
_amazon_sync_service = None


# =============================================================================
# DEPENDENCIES
# =============================================================================

def get_order_repository():
    """
    Get order repository instance.
    
    TODO: Replace with real SQLAlchemy repository.
    """
    global _order_repository
    
    if _order_repository is None:
        _order_repository = MockOrderRepository()
        logger.info("Created MockOrderRepository instance")
    
    return _order_repository


def get_odoo_client():
    """
    Get Odoo client instance.
    
    TODO: Replace with real Odoo XML-RPC client.
    """
    global _odoo_client
    
    if _odoo_client is None:
        _odoo_client = MockOdooClient()
        logger.info("Created MockOdooClient instance")
    
    return _odoo_client


def get_notification_service():
    """
    Get notification service instance.
    
    TODO: Replace with real Telegram/WhatsApp service.
    """
    global _notification_service
    
    if _notification_service is None:
        _notification_service = MockNotificationService()
        logger.info("Created MockNotificationService instance")
    
    return _notification_service


def get_sync_order_use_case() -> SyncAmazonOrderUseCase:
    """
    Get sync order use case instance.
    
    This is the main business logic entry point.
    """
    global _sync_order_use_case
    
    if _sync_order_use_case is None:
        _sync_order_use_case = SyncAmazonOrderUseCase(
            order_repository=get_order_repository(),
            odoo_client=get_odoo_client(),
            notification_service=get_notification_service()
        )
        logger.info("Created SyncAmazonOrderUseCase instance")
    
    return _sync_order_use_case


def get_amazon_sync_service() -> AmazonSyncService:
    """
    Get Amazon sync service instance.
    
    This is the high-level service layer.
    """
    global _amazon_sync_service
    
    if _amazon_sync_service is None:
        _amazon_sync_service = AmazonSyncService(
            sync_order_use_case=get_sync_order_use_case()
        )
        logger.info("Created AmazonSyncService instance")
    
    return _amazon_sync_service


# =============================================================================
# RESET (for testing)
# =============================================================================

def reset_dependencies():
    """Reset all dependencies (for testing)."""
    global _order_repository, _odoo_client, _notification_service
    global _sync_order_use_case, _amazon_sync_service
    
    _order_repository = None
    _odoo_client = None
    _notification_service = None
    _sync_order_use_case = None
    _amazon_sync_service = None
    
    logger.info("Dependencies reset")

üî® Task 9.3: Amazon Routes
ŸÖŸÑŸÅ: api/routes/amazon.py
python"""
Amazon order sync endpoints.

Provides REST API for syncing Amazon orders to Odoo.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
import logging

from core.application.services.amazon_sync_service import AmazonSyncService
from core.application.dto import (
    OrderSyncRequestDTO,
    OrderSyncResponseDTO,
    BatchSyncRequestDTO,
    BatchSyncResponseDTO,
)
from api.dependencies import get_amazon_sync_service


logger = logging.getLogger(__name__)
router = APIRouter()


# =============================================================================
# SYNC SINGLE ORDER
# =============================================================================

@router.post(
    "/sync",
    response_model=OrderSyncResponseDTO,
    status_code=status.HTTP_200_OK,
    summary="Sync single Amazon order",
    description="""
    Sync a single Amazon order to Odoo.
    
    **Workflow:**
    1. Extract financial breakdown from Amazon Financial Events
    2. Validate financials (balance equation)
    3. Create Order entity
    4. Save to database
    5. Create Odoo invoice
    6. Send notifications
    
    **Dry Run Mode:**
    Set `dry_run=true` to validate without creating invoice or saving to database.
    """
)
async def sync_amazon_order(
    request: OrderSyncRequestDTO,
    service: AmazonSyncService = Depends(get_amazon_sync_service)
):
    """
    Sync single Amazon order to Odoo.
    
    **Request Body:**
    - `amazon_order_id`: Amazon Order ID (format: XXX-XXXXXXX-XXXXXXX)
    - `financial_events`: Amazon Financial Events API response
    - `buyer_email`: Optional buyer email for partner lookup
    - `dry_run`: If true, validates without persisting
    
    **Returns:**
    - Sync response with execution ID, invoice ID, and financial data
    """
    logger.info(f"API: Sync order request: {request.amazon_order_id}")
    
    try:
        # Execute sync
        response = await service.sync_single_order(
            order_id=request.amazon_order_id,
            financial_events=request.financial_events,
            buyer_email=request.buyer_email,
            dry_run=request.dry_run
        )
        
        # Check if successful
        if not response.success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={
                    "error": response.error,
                    "details": response.error_details,
                    "execution_id": str(response.execution_id.value)
                }
            )
        
        # Return DTO
        return OrderSyncResponseDTO(
            execution_id=str(response.execution_id.value),
            order_id=response.order_id.value,
            success=response.success,
            principal_amount=response.principal_amount,
            net_proceeds=response.net_proceeds,
            odoo_invoice_id=response.odoo_invoice_id,
            error=response.error,
            error_details=response.error_details,
            timestamp=response.timestamp
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Sync failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Sync failed: {str(e)}"
        )


# =============================================================================
# SYNC BATCH
# =============================================================================

@router.post(
    "/sync-batch",
    response_model=BatchSyncResponseDTO,
    status_code=status.HTTP_200_OK,
    summary="Sync multiple Amazon orders",
    description="""
    Sync multiple Amazon orders in batch.
    
    **Features:**
    - Process multiple orders in parallel
    - Continue on error (configurable)
    - Batch statistics and summary
    - Dry run mode support
    """
)
async def sync_amazon_orders_batch(
    request: BatchSyncRequestDTO,
    service: AmazonSyncService = Depends(get_amazon_sync_service)
):
    """
    Sync multiple Amazon orders in batch.
    
    **Request Body:**
    - `orders`: List of order sync requests
    - `continue_on_error`: If true, continues even if some orders fail
    - `dry_run`: If true, validates all orders without persisting
    
    **Returns:**
    - Batch response with individual results and statistics
    """
    logger.info(f"API: Batch sync request: {len(request.orders)} orders")
    
    try:
        import time
        start_time = time.time()
        
        # Prepare orders data
        orders_data = [
            {
                "order_id": order.amazon_order_id,
                "financial_events": order.financial_events,
                "buyer_email": order.buyer_email
            }
            for order in request.orders
        ]
        
        # Execute batch sync
        responses = await service.sync_multiple_orders(
            orders_data=orders_data,
            continue_on_error=request.continue_on_error,
            dry_run=request.dry_run
        )
        
        # Get statistics
        stats = await service.get_sync_statistics(responses)
        
        # Calculate execution time
        execution_time = time.time() - start_time
        
        # Convert responses to DTOs
        result_dtos = [
            OrderSyncResponseDTO(
                execution_id=str(resp.execution_id.value),
                order_id=resp.order_id.value,
                success=resp.success,
                principal_amount=resp.principal_amount,
                net_proceeds=resp.net_proceeds,
                odoo_invoice_id=resp.odoo_invoice_id,
                error=resp.error,
                error_details=resp.error_details,
                timestamp=resp.timestamp
            )
            for resp in responses
        ]
        
        # Return batch response
        return BatchSyncResponseDTO(
            total_orders=stats['total_orders'],
            successful=stats['successful'],
            failed=stats['failed'],
            results=result_dtos,
            execution_time_seconds=execution_time
        )
    
    except Exception as e:
        logger.error(f"Batch sync failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Batch sync failed: {str(e)}"
        )

üî® Task 9.4: Orders Routes
ŸÖŸÑŸÅ: api/routes/orders.py
python"""
Orders management endpoints.

Provides CRUD operations for orders.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
import logging

from core.domain.value_objects import OrderNumber
from api.dependencies import get_order_repository


logger = logging.getLogger(__name__)
router = APIRouter()


# =============================================================================
# LIST ORDERS
# =============================================================================

@router.get(
    "",
    status_code=status.HTTP_200_OK,
    summary="List all orders",
    description="Get list of all orders in the system"
)
async def list_orders(
    repository=Depends(get_order_repository)
):
    """
    List all orders.
    
    **Returns:**
    - List of orders with basic information
    """
    try:
        orders = repository.get_all()
        
        return {
            "total": len(orders),
            "orders": [
                {
                    "order_id": order.order_id.value,
                    "marketplace": order.marketplace,
                    "purchase_date": order.purchase_date.isoformat(),
                    "status": order.order_status,
                    "principal": float(order.financial_breakdown.principal.amount) if order.financial_breakdown else None,
                    "net_proceeds": float(order.financial_breakdown.net_proceeds.amount) if order.financial_breakdown else None,
                }
                for order in orders
            ]
        }
    
    except Exception as e:
        logger.error(f"List orders failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list orders: {str(e)}"
        )


# =============================================================================
# GET ORDER BY ID
# =============================================================================

@router.get(
    "/{order_id}",
    status_code=status.HTTP_200_OK,
    summary="Get order by ID",
    description="Get detailed information about a specific order"
)
async def get_order(
    order_id: str,
    repository=Depends(get_order_repository)
):
    """
    Get order by ID.
    
    **Parameters:**
    - `order_id`: Amazon/Noon order ID
    
    **Returns:**
    - Detailed order information including financial breakdown
    """
    try:
        order = await repository.get_by_id(OrderNumber(value=order_id))
        
        if not order:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Order not found: {order_id}"
            )
        
        # Build response
        response = {
            "order_id": order.order_id.value,
            "marketplace": order.marketplace,
            "purchase_date": order.purchase_date.isoformat(),
            "buyer_email": order.buyer_email,
            "status": order.order_status,
        }
        
        # Add financial breakdown if available
        if order.financial_breakdown:
            response["financial_breakdown"] = {
                "principal": {
                    "amount": float(order.financial_breakdown.principal.amount),
                    "currency": order.financial_breakdown.principal.currency
                },
                "net_proceeds": {
                    "amount": float(order.financial_breakdown.net_proceeds.amount),
                    "currency": order.financial_breakdown.net_proceeds.currency
                },
                "financial_lines": [
                    {
                        "type": line.line_type,
                        "description": line.description,
                        "amount": float(line.amount.amount),
                        "sku": line.sku
                    }
                    for line in order.financial_breakdown.financial_lines
                ]
            }
        
        # Add execution ID if available
        if order.execution_id:
            response["execution_id"] = str(order.execution_id.value)
        
        return response
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Get order failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get order: {str(e)}"
        )

üî® Task 9.5: Route Exports
ŸÖŸÑŸÅ: api/routes/__init__.py
python"""API routes."""
from . import amazon, orders, health

__all__ = ["amazon", "orders", "health"]

‚úÖ ÿßŸÑÿ¢ŸÜ ÿ¥ÿ∫ŸëŸÑ ÿßŸÑŸÄ API!
bashcd /home/claude

# Install FastAPI and uvicorn (if not installed)
pip install fastapi uvicorn python-multipart --break-system-packages

# Run the API
uvicorn api.main:app --host 0.0.0.0 --port 8000 --reload

üß™ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÄ API
bash# Test 1: Health check
curl http://localhost:8000/health

# Test 2: Sync single order (with test data)
curl -X POST http://localhost:8000/api/v1/amazon/sync \
  -H "Content-Type: application/json" \
  -d '{
    "amazon_order_id": "407-1263947-9146736",
    "financial_events": {...},
    "dry_run": true
  }'

# Test 3: List orders
curl http://localhost:8000/api/v1/orders

ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿ™ŸÜŸÅŸäÿ∞ÿü üöÄ
ÿ£ÿÆÿ®ÿ±ŸÜŸä ÿπŸÜÿØŸÖÿß ÿ™ŸÜÿ™ŸáŸä ŸÖŸÜ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÑŸÅÿßÿ™ÿå Ÿàÿ≥ÿ£ÿπÿ∑ŸäŸÉ:

Test script ŸÉÿßŸÖŸÑ
Postman collection
OpenAPI documentation guide
